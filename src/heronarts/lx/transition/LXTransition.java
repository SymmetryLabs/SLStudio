/**
 * ##library.name##
 * ##library.sentence##
 * ##library.url##
 *
 * Copyright ##copyright## ##author##
 * All Rights Reserved
 * 
 * @author      ##author##
 * @modified    ##date##
 * @version     ##library.prettyVersion## (##library.version##)
 */

package heronarts.lx.transition;

import heronarts.lx.LX;
import heronarts.lx.LXComponent;
import heronarts.lx.control.BasicParameter;

/**
 * An object interface to blend two patterns together. All
 * transitions have a duration and generate a new array of
 * colors based upon a source pattern and a destination
 * pattern. Transitions also support easing.
 */
public abstract class LXTransition extends LXComponent {
    
    /**
     * Constants for easing that should be applied to the transition.
     */
    public enum Ease {
        /**
         * Apply no easing to the transition
         */
        NONE,
        
        /**
         * Apply easing to the start of the transition
         */
        IN,
        
        /**
         * Apply easing to the end of the transition
         */
        OUT,
        
        /**
         * Apply easing to both the start and end of the transition
         */
        INOUT
    }
    
    public class Timer {
        public long blendNanos = 0;
    }
    
    private final static double DEFAULT_DURATION = 1000;
    
    public final Timer timer = new Timer();
    
    protected final LX lx; 
    protected final int[] colors;
    
    private BasicParameter duration;
    private Ease ease;
    
    /**
     * Default abstract constructor.
     * 
     * @param lx
     */
    protected LXTransition(LX lx) {
        this.lx = lx;
        this.colors = new int[lx.total];
        this.duration = new BasicParameter("DURATION", 0);
        setDuration(LXTransition.DEFAULT_DURATION);
        this.addParameter(this.duration);
        this.ease = Ease.NONE;
    }
    
    /**
     * Returns the blended colors generated by this transition
     * 
     * @return An array of the blended colors generated by this transition
     */
    final public int[] getColors() {
        return this.colors;
    }
    
    /**
     * Returns the duration of the transition
     * 
     * @return The number of milliseconds this transition lasts for
     */
    final public double getDuration() {
        double durVal = duration.getValue();
        return 100. + (durVal*durVal) * 9900.;
    }
    
    /**
     * Modifies the duration of this transition
     * 
     * @param duration Number of milliseconds the transition lasts for
     * @return This transition, for method chaining
     */
    public LXTransition setDuration(double duration) {
        this.duration.setValue(Math.sqrt((duration-100)/9900.));
        return this;
    }
    
    /**
     * Modifies the easing of this transition
     * 
     * @param ease Easing value to apply to transition
     * @return This transition, for method chaining
     */
    public LXTransition setEase(Ease ease) {
        this.ease = ease;
        return this;
    }

    private double easeIn(double value) {
        return (4.*value)*(4.*value) / 16.;
    }
    
    private double easeOut(double value) {
        return 1. - this.easeIn(1.-value);
    }

    private double ease(double value) {
        switch (this.ease) {
        case NONE:
            break;
        case IN:
            value = this.easeIn(value);
            break;
        case OUT:
            value = this.easeOut(value);
            break;
        case INOUT:
            if (value < 0.5) {
                value = this.easeIn(2.*value) / 2.;
            } else {
                value = 0.5 + this.easeOut(2.*(value-0.5))/2.;
            }
            break;
        }
        return value;
    }
    
    /**
     * Invoked by the Engine. After this method is called getColors()
     * will return the blended colors.
     * 
     * @param c1 Colors being blended from
     * @param c2 Colors being blended to
     * @param progress Progress of blend, from 0 to 1
     */
    public final void blend(int[] c1, int[] c2, double progress) {
        long blendStart = System.nanoTime(); 
        this.computeBlend(c1, c2, this.ease(progress));
        this.timer.blendNanos = System.nanoTime() - blendStart;
    }
    
    /**
     * Method that concrete transition classes should implement. Should
     * update the internal colors array appropriately. 
     * 
     * @param c1 Colors being blended from
     * @param c2 Colors being blended to
     * @param progress Progress of blend, easing already applied, from 0 to 1
     */
    protected abstract void computeBlend(int[] c1, int[] c2, double progress);
    
}
